/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosStatic, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
import appConfig from "../../appConfig";
import {apiAxios} from "./ApiAxios";

export class LabelsClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    labelsForProject(projectId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<LabelDto[]> {
        let url_ = this.baseUrl + "/api/Labels/labels-for-project?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLabelsForProject(_response);
        });
    }

    protected processLabelsForProject(response: AxiosResponse): Promise<LabelDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelDto[]>(<any>null);
    }

    searchLabelsForProject(projectId?: number | undefined, searchTerm?: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<LabelDto[]> {
        let url_ = this.baseUrl + "/api/Labels/search-labels-for-project?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchLabelsForProject(_response);
        });
    }

    protected processSearchLabelsForProject(response: AxiosResponse): Promise<LabelDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LabelDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelDto[]>(<any>null);
    }

    add(dto: AddLabelDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Labels/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    update(dto: UpdateLabelDto , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Labels/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AccountClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    getInfo(  cancelToken?: CancelToken | undefined): Promise<AccountInfoDto> {
        let url_ = this.baseUrl + "/api/Account/get-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInfo(_response);
        });
    }

    protected processGetInfo(response: AxiosResponse): Promise<AccountInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountInfoDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountInfoDto>(<any>null);
    }
}

export class AuthenticationClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    login(request: LoginRequest , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Authentication/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    register(request: RegisterRequest , cancelToken?: CancelToken | undefined): Promise<ServiceReponse> {
        let url_ = this.baseUrl + "/api/Authentication/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<ServiceReponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceReponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceReponse>(<any>null);
    }
}

export class IssuesClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    get(issueId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<IssueDetailsDto> {
        let url_ = this.baseUrl + "/api/Issues/get?";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<IssueDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IssueDetailsDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IssueDetailsDto>(<any>null);
    }

    search(projectId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<IssueDto[]> {
        let url_ = this.baseUrl + "/api/Issues/search?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<IssueDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IssueDto[]>(<any>null);
    }

    add(dto: AddIssueDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Issues/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    update(dto: UpdateIssueDto , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Issues/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    updateStatus(issueId?: number | undefined, issueStatusId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Issues/update-status?";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        if (issueStatusId === null)
            throw new Error("The parameter 'issueStatusId' cannot be null.");
        else if (issueStatusId !== undefined)
            url_ += "issueStatusId=" + encodeURIComponent("" + issueStatusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    assignToMyself(issueId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Issues/assign-to-myself?";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignToMyself(_response);
        });
    }

    protected processAssignToMyself(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    reorderIssues(issueIds: number[] , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Issues/reorder-issues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(issueIds);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReorderIssues(_response);
        });
    }

    protected processReorderIssues(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class IssueStatusesClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    getForProject(projectId: number , cancelToken?: CancelToken | undefined): Promise<IssueStatusDto[]> {
        let url_ = this.baseUrl + "/api/IssueStatuses/get-for-project/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetForProject(_response);
        });
    }

    protected processGetForProject(response: AxiosResponse): Promise<IssueStatusDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueStatusDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IssueStatusDto[]>(<any>null);
    }
}

export class ProjectsClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    getAll(  cancelToken?: CancelToken | undefined): Promise<ProjectDto[]> {
        let url_ = this.baseUrl + "/api/Projects/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ProjectDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectDto[]>(<any>null);
    }

    add(dto: AddProjectDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Projects/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    update(dto: UpdateProjectDto , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Projects/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    details(id: number , cancelToken?: CancelToken | undefined): Promise<ProjectDetailsDto> {
        let url_ = this.baseUrl + "/api/Projects/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetails(_response);
        });
    }

    protected processDetails(response: AxiosResponse): Promise<ProjectDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectDetailsDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectDetailsDto>(<any>null);
    }
}

export class UsersClient {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    usersForProject(projectId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<ProjectUserDto[]> {
        let url_ = this.baseUrl + "/api/Users/users-for-project?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersForProject(_response);
        });
    }

    protected processUsersForProject(response: AxiosResponse): Promise<ProjectUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectUserDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectUserDto[]>(<any>null);
    }

    addUserToProject(email?: string | null | undefined, projectId?: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Users/add-user-to-project?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserToProject(_response);
        });
    }

    protected processAddUserToProject(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class Client {
    private instance = apiAxios;
    // @ts-ignore
    private baseUrl: string = appConfig.apiUrl

    weatherForecast(  cancelToken?: CancelToken | undefined): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWeatherForecast(_response);
        });
    }

    protected processWeatherForecast(response: AxiosResponse): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WeatherForecast[]>(<any>null);
    }
}

export class LabelDto implements ILabelDto {
    id!: number;
    name!: string | null;

    constructor(data?: ILabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new LabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ILabelDto {
    id: number;
    name: string | null;
}

export class AddLabelDto implements IAddLabelDto {
    projectId!: number;
    name!: string | null;

    constructor(data?: IAddLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): AddLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IAddLabelDto {
    projectId: number;
    name: string | null;
}

export class UpdateLabelDto implements IUpdateLabelDto {
    id!: number;
    name!: string | null;

    constructor(data?: IUpdateLabelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateLabelDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLabelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IUpdateLabelDto {
    id: number;
    name: string | null;
}

export class AccountInfoDto implements IAccountInfoDto {
    id!: number;
    email!: string | null;
    name!: string | null;

    constructor(data?: IAccountInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): AccountInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IAccountInfoDto {
    id: number;
    email: string | null;
    name: string | null;
}

export class LoginRequest implements ILoginRequest {
    email!: string | null;
    password!: string | null;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface ILoginRequest {
    email: string | null;
    password: string | null;
}

export class ServiceReponse implements IServiceReponse {
    isSuccessful!: boolean;
    errorMessage!: string | null;

    constructor(data?: IServiceReponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"] !== undefined ? _data["isSuccessful"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ServiceReponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceReponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful !== undefined ? this.isSuccessful : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data; 
    }
}

export interface IServiceReponse {
    isSuccessful: boolean;
    errorMessage: string | null;
}

export class RegisterRequest implements IRegisterRequest {
    name!: string | null;
    email!: string | null;
    password!: string | null;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IRegisterRequest {
    name: string | null;
    email: string | null;
    password: string | null;
}

export class IssueDetailsDto implements IIssueDetailsDto {
    id!: number;
    reference!: string | null;
    title!: string | null;
    assignedUserId!: number | null;
    statusId!: number;
    description!: string | null;
    createdByUserId!: number;
    projectId!: number;
    labels!: LabelDto[];

    constructor(data?: IIssueDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.reference = _data["reference"] !== undefined ? _data["reference"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.assignedUserId = _data["assignedUserId"] !== undefined ? _data["assignedUserId"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(LabelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssueDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["reference"] = this.reference !== undefined ? this.reference : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["assignedUserId"] = this.assignedUserId !== undefined ? this.assignedUserId : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIssueDetailsDto {
    id: number;
    reference: string | null;
    title: string | null;
    assignedUserId: number | null;
    statusId: number;
    description: string | null;
    createdByUserId: number;
    projectId: number;
    labels: LabelDto[];
}

export class IssueDto implements IIssueDto {
    id!: number;
    reference!: string | null;
    title!: string | null;
    statusId!: number;
    statusName!: string | null;
    assignedUserId!: number | null;
    userName!: string | null;
    labels!: LabelDto[] | null;

    constructor(data?: IIssueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.reference = _data["reference"] !== undefined ? _data["reference"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
            this.statusName = _data["statusName"] !== undefined ? _data["statusName"] : <any>null;
            this.assignedUserId = _data["assignedUserId"] !== undefined ? _data["assignedUserId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(LabelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["reference"] = this.reference !== undefined ? this.reference : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        data["statusName"] = this.statusName !== undefined ? this.statusName : <any>null;
        data["assignedUserId"] = this.assignedUserId !== undefined ? this.assignedUserId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIssueDto {
    id: number;
    reference: string | null;
    title: string | null;
    statusId: number;
    statusName: string | null;
    assignedUserId: number | null;
    userName: string | null;
    labels: LabelDto[] | null;
}

export class AddIssueDto implements IAddIssueDto {
    projectId!: number;
    title!: string | null;
    description!: string | null;
    text!: string | null;
    assignedUserId!: number | null;
    statusId!: number;

    constructor(data?: IAddIssueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.assignedUserId = _data["assignedUserId"] !== undefined ? _data["assignedUserId"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
        }
    }

    static fromJS(data: any): AddIssueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddIssueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["assignedUserId"] = this.assignedUserId !== undefined ? this.assignedUserId : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        return data; 
    }
}

export interface IAddIssueDto {
    projectId: number;
    title: string | null;
    description: string | null;
    text: string | null;
    assignedUserId: number | null;
    statusId: number;
}

export class UpdateIssueDto implements IUpdateIssueDto {
    title!: string | null;
    text!: string | null;
    assignedUserId!: number | null;
    statusId!: number;
    id!: number;
    labelIds!: number[] | null;

    constructor(data?: IUpdateIssueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.text = _data["text"] !== undefined ? _data["text"] : <any>null;
            this.assignedUserId = _data["assignedUserId"] !== undefined ? _data["assignedUserId"] : <any>null;
            this.statusId = _data["statusId"] !== undefined ? _data["statusId"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            if (Array.isArray(_data["labelIds"])) {
                this.labelIds = [] as any;
                for (let item of _data["labelIds"])
                    this.labelIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateIssueDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIssueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["text"] = this.text !== undefined ? this.text : <any>null;
        data["assignedUserId"] = this.assignedUserId !== undefined ? this.assignedUserId : <any>null;
        data["statusId"] = this.statusId !== undefined ? this.statusId : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (Array.isArray(this.labelIds)) {
            data["labelIds"] = [];
            for (let item of this.labelIds)
                data["labelIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateIssueDto {
    title: string | null;
    text: string | null;
    assignedUserId: number | null;
    statusId: number;
    id: number;
    labelIds: number[] | null;
}

export class IssueStatusDto implements IIssueStatusDto {
    id!: number;
    name!: string;

    constructor(data?: IIssueStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): IssueStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new IssueStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IIssueStatusDto {
    id: number;
    name: string;
}

export class ProjectDto implements IProjectDto {
    id!: number;
    name!: string | null;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IProjectDto {
    id: number;
    name: string | null;
}

export class AddProjectDto implements IAddProjectDto {
    name!: string | null;
    abbreviation!: string | null;
    statuses!: CreateIssueStatusDto[] | null;

    constructor(data?: IAddProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.abbreviation = _data["abbreviation"] !== undefined ? _data["abbreviation"] : <any>null;
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(CreateIssueStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["abbreviation"] = this.abbreviation !== undefined ? this.abbreviation : <any>null;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddProjectDto {
    name: string | null;
    abbreviation: string | null;
    statuses: CreateIssueStatusDto[] | null;
}

export class CreateIssueStatusDto implements ICreateIssueStatusDto {
    priority!: number;
    name!: string | null;

    constructor(data?: ICreateIssueStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priority = _data["priority"] !== undefined ? _data["priority"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CreateIssueStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIssueStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority !== undefined ? this.priority : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICreateIssueStatusDto {
    priority: number;
    name: string | null;
}

export class UpdateProjectDto implements IUpdateProjectDto {
    id!: number;
    name!: string | null;
    abbreviation!: string | null;
    statuses!: UpdateProjectStatusDto[] | null;

    constructor(data?: IUpdateProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.abbreviation = _data["abbreviation"] !== undefined ? _data["abbreviation"] : <any>null;
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(UpdateProjectStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["abbreviation"] = this.abbreviation !== undefined ? this.abbreviation : <any>null;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateProjectDto {
    id: number;
    name: string | null;
    abbreviation: string | null;
    statuses: UpdateProjectStatusDto[] | null;
}

export class UpdateProjectStatusDto implements IUpdateProjectStatusDto {
    id!: number | null;
    name!: string | null;

    constructor(data?: IUpdateProjectStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateProjectStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IUpdateProjectStatusDto {
    id: number | null;
    name: string | null;
}

export class ProjectDetailsDto implements IProjectDetailsDto {
    id!: number;
    name!: string | null;
    abbreviation!: string | null;

    constructor(data?: IProjectDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.abbreviation = _data["abbreviation"] !== undefined ? _data["abbreviation"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["abbreviation"] = this.abbreviation !== undefined ? this.abbreviation : <any>null;
        return data; 
    }
}

export interface IProjectDetailsDto {
    id: number;
    name: string | null;
    abbreviation: string | null;
}

export class ProjectUserDto implements IProjectUserDto {
    id!: number;
    name!: string | null;
    email!: string | null;

    constructor(data?: IProjectUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): ProjectUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data; 
    }
}

export interface IProjectUserDto {
    id: number;
    name: string | null;
    email: string | null;
}

export class WeatherForecast implements IWeatherForecast {
    date!: Date;
    temperatureC!: number;
    temperatureF!: number;
    summary!: string | null;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.temperatureC = _data["temperatureC"] !== undefined ? _data["temperatureC"] : <any>null;
            this.temperatureF = _data["temperatureF"] !== undefined ? _data["temperatureF"] : <any>null;
            this.summary = _data["summary"] !== undefined ? _data["summary"] : <any>null;
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["temperatureC"] = this.temperatureC !== undefined ? this.temperatureC : <any>null;
        data["temperatureF"] = this.temperatureF !== undefined ? this.temperatureF : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        return data; 
    }
}

export interface IWeatherForecast {
    date: Date;
    temperatureC: number;
    temperatureF: number;
    summary: string | null;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}